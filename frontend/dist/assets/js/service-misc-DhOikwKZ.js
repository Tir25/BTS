import{a as t,l as e,e as s}from"./component-driver-DClzc_eh.js";import{a}from"./service-auth-DEUayG_-.js";class r{constructor(t,e={failureThreshold:5,recoveryTimeout:6e4,expectedErrors:[],monitorInterval:3e4}){this.name=t,this.config=e,this.startMonitoring()}state="CLOSED";failureCount=0;lastFailureTime;lastSuccessTime;nextAttemptTime;totalRequests=0;successfulRequests=0;failedRequests=0;monitorTimer;async execute(t,e){if(this.totalRequests++,"OPEN"===this.state){if(!this.shouldAttemptReset()){if(e)return e();throw new Error(`Circuit breaker '${this.name}' is OPEN`)}this.transitionToHalfOpen()}try{const e=await t();return this.onSuccess(),e}catch(s){if(this.onFailure(s),e)return e();throw s}}onSuccess(){this.successfulRequests++,this.lastSuccessTime=Date.now(),this.failureCount=0,"HALF_OPEN"===this.state&&this.transitionToClosed()}onFailure(t){this.failedRequests++,this.lastFailureTime=Date.now();const e=t?.message||t?.message||t?.toString()||"";this.config.expectedErrors.some(t=>"string"==typeof e&&e.includes(t))||(this.failureCount++,this.failureCount>=this.config.failureThreshold&&this.transitionToOpen())}transitionToOpen(){"OPEN"!==this.state&&(this.state="OPEN",this.nextAttemptTime=Date.now()+this.config.recoveryTimeout)}transitionToHalfOpen(){this.state="HALF_OPEN"}transitionToClosed(){this.state="CLOSED",this.failureCount=0,this.nextAttemptTime=void 0}shouldAttemptReset(){return void 0!==this.nextAttemptTime&&Date.now()>=this.nextAttemptTime}startMonitoring(){this.monitorTimer=setInterval(()=>{this.logMetrics()},this.config.monitorInterval)}logMetrics(){this.getMetrics()}getMetrics(){return{totalRequests:this.totalRequests,successfulRequests:this.successfulRequests,failedRequests:this.failedRequests,lastFailureTime:this.lastFailureTime,lastSuccessTime:this.lastSuccessTime,currentState:this.state,failureCount:this.failureCount}}reset(){this.transitionToClosed()}destroy(){this.monitorTimer&&clearInterval(this.monitorTimer)}}const n=new class{breakers=new Map;create(t,e){if(this.breakers.has(t))return this.breakers.get(t);const s=new r(t,e);return this.breakers.set(t,s),s}get(t){return this.breakers.get(t)}getAll(){return new Map(this.breakers)}reset(t){const e=this.breakers.get(t);e&&e.reset()}resetAll(){this.breakers.forEach(t=>t.reset())}destroy(){this.breakers.forEach(t=>t.destroy()),this.breakers.clear()}},i=n.create("api",{failureThreshold:3,recoveryTimeout:3e4,expectedErrors:["401","403","404"],monitorInterval:15e3});n.create("websocket",{failureThreshold:5,recoveryTimeout:6e4,expectedErrors:[],monitorInterval:3e4}),n.create("supabase",{failureThreshold:3,recoveryTimeout:45e3,expectedErrors:["401","403"],monitorInterval:2e4});const o=new class{constructor(t={initialDelay:1e3,maxDelay:3e4,multiplier:2,maxAttempts:5,jitter:!0,jitterFactor:.1}){this.config=t}attemptCount=0;startTime=0;async execute(t,e){for(this.attemptCount=0,this.startTime=Date.now();this.attemptCount<this.config.maxAttempts;)try{return{success:!0,result:await t(),attempts:this.attemptCount+1,totalTime:Date.now()-this.startTime}}catch(s){if(this.attemptCount++,this.attemptCount>=this.config.maxAttempts)return{success:!1,error:s instanceof Error?s:new Error(String(s)),attempts:this.attemptCount,totalTime:Date.now()-this.startTime};const t=this.calculateDelay();e&&e(this.attemptCount,t,s instanceof Error?s:new Error(String(s))),await this.sleep(t)}return{success:!1,error:new Error("Max retry attempts exceeded"),attempts:this.attemptCount,totalTime:Date.now()-this.startTime}}calculateDelay(){const t=Math.min(this.config.initialDelay*Math.pow(this.config.multiplier,this.attemptCount-1),this.config.maxDelay);if(!this.config.jitter)return t;const e=t*this.config.jitterFactor,s=(Math.random()-.5)*e;return Math.max(0,t+s)}sleep(t){return new Promise(e=>setTimeout(e,t))}reset(){this.attemptCount=0,this.startTime=0}getAttemptCount(){return this.attemptCount}getRemainingAttempts(){return Math.max(0,this.config.maxAttempts-this.attemptCount)}}({initialDelay:1e3,maxDelay:3e4,multiplier:2,maxAttempts:5,jitter:!0,jitterFactor:.15});const c=new class{constructor(t={dbName:"BusTrackingOffline",dbVersion:1,maxAge:864e5,maxSize:1e3,syncInterval:3e4}){this.config=t,this.initializeDB(),this.setupNetworkListeners(),this.startSyncTimer()}db=null;syncTimer=null;isOnline=navigator.onLine;async initializeDB(){return new Promise((t,e)=>{const s=indexedDB.open(this.config.dbName,this.config.dbVersion);s.onerror=()=>{e(s.error)},s.onsuccess=()=>{this.db=s.result,t()},s.onupgradeneeded=t=>{const e=t.target.result;if(!e.objectStoreNames.contains("offlineData")){const t=e.createObjectStore("offlineData",{keyPath:"id"});t.createIndex("type","type",{unique:!1}),t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("syncStatus","syncStatus",{unique:!1})}if(!e.objectStoreNames.contains("syncQueue")){const t=e.createObjectStore("syncQueue",{keyPath:"id"});t.createIndex("timestamp","timestamp",{unique:!1}),t.createIndex("retryCount","retryCount",{unique:!1})}}})}setupNetworkListeners(){window.addEventListener("online",()=>{this.isOnline=!0,this.syncPendingData()}),window.addEventListener("offline",()=>{this.isOnline=!1})}startSyncTimer(){this.syncTimer&&clearInterval(this.syncTimer),this.syncTimer=setInterval(()=>{this.isOnline&&this.syncPendingData()},this.config.syncInterval)}async storeData(t,e,s){if(!this.db)throw new Error("IndexedDB not initialized");const a={id:e,type:t,data:s,timestamp:Date.now(),version:1,syncStatus:"synced"};return new Promise((t,e)=>{const s=this.db.transaction(["offlineData"],"readwrite").objectStore("offlineData").put(a);s.onsuccess=()=>{t()},s.onerror=()=>{e(s.error)}})}async getData(t,e){return this.db?new Promise((s,a)=>{const r=this.db.transaction(["offlineData"],"readonly").objectStore("offlineData").get(e);r.onsuccess=()=>{const a=r.result;a&&a.type===t?Date.now()-a.timestamp<this.config.maxAge?s(a.data):(this.removeData(t,e),s(null)):s(null)},r.onerror=()=>{a(r.error)}}):null}async getAllData(t){return this.db?new Promise((e,s)=>{const a=this.db.transaction(["offlineData"],"readonly").objectStore("offlineData").index("type").getAll(t);a.onsuccess=()=>{const t=a.result.filter(t=>Date.now()-t.timestamp<this.config.maxAge).map(t=>t.data);e(t)},a.onerror=()=>{s(a.error)}}):[]}async removeData(t,e){if(this.db)return new Promise((t,s)=>{const a=this.db.transaction(["offlineData"],"readwrite").objectStore("offlineData").delete(e);a.onsuccess=()=>{t()},a.onerror=()=>{s(a.error)}})}async addToSyncQueue(t,e,s){if(!this.db)throw new Error("IndexedDB not initialized");const a={id:`${t}_${Date.now()}_${Math.random()}`,operation:t,endpoint:e,data:s,timestamp:Date.now(),retryCount:0};return new Promise((t,e)=>{const s=this.db.transaction(["syncQueue"],"readwrite").objectStore("syncQueue").put(a);s.onsuccess=()=>{t()},s.onerror=()=>{e(s.error)}})}async getSyncQueue(){return this.db?new Promise((t,e)=>{const s=this.db.transaction(["syncQueue"],"readonly").objectStore("syncQueue").getAll();s.onsuccess=()=>{t(s.result)},s.onerror=()=>{e(s.error)}}):[]}async removeFromSyncQueue(t){if(this.db)return new Promise((e,s)=>{const a=this.db.transaction(["syncQueue"],"readwrite").objectStore("syncQueue").delete(t);a.onsuccess=()=>{e()},a.onerror=()=>{s(a.error)}})}async updateRetryCount(t,e){if(this.db)return new Promise((s,a)=>{const r=this.db.transaction(["syncQueue"],"readwrite").objectStore("syncQueue"),n=r.get(t);n.onsuccess=()=>{const t=n.result;if(t){t.retryCount=e;const n=r.put(t);n.onsuccess=()=>s(),n.onerror=()=>a(n.error)}else s()},n.onerror=()=>a(n.error)})}async syncPendingData(){if(!this.isOnline)return;const t=await this.getSyncQueue();if(0!==t.length)for(const s of t)try{const t=await fetch(s.endpoint,{method:"delete"===s.operation?"DELETE":"POST",headers:{"Content-Type":"application/json"},body:"delete"!==s.operation?JSON.stringify(s.data):void 0});if(!t.ok)throw new Error(`HTTP ${t.status}`);await this.removeFromSyncQueue(s.id)}catch(e){const t=s.retryCount+1;await this.updateRetryCount(s.id,t),t>=5&&await this.removeFromSyncQueue(s.id)}}async clearAll(){if(this.db)return new Promise((t,e)=>{const s=this.db.transaction(["offlineData","syncQueue"],"readwrite"),a=s.objectStore("offlineData"),r=s.objectStore("syncQueue"),n=a.clear(),i=r.clear();n.onsuccess=()=>{i.onsuccess=()=>{t()},i.onerror=()=>e(i.error)},n.onerror=()=>e(n.error)})}async getStats(){return this.db?new Promise((t,e)=>{const s=this.db.transaction(["offlineData","syncQueue"],"readonly"),a=s.objectStore("offlineData"),r=s.objectStore("syncQueue"),n=a.getAll(),i=r.getAll();n.onsuccess=()=>{i.onsuccess=()=>{const e=n.result,s=i.result,a={};e.forEach(t=>{a[t.type]=(a[t.type]||0)+1}),t({totalItems:e.length,dataByType:a,queueItems:s.length,totalSize:JSON.stringify(e).length+JSON.stringify(s).length})},i.onerror=()=>e(i.error)},n.onerror=()=>e(n.error)}):{totalItems:0,dataByType:{},queueItems:0,totalSize:0}}destroy(){this.syncTimer&&clearInterval(this.syncTimer)}};new class{baseUrl;defaultTimeout=1e4;constructor(e){this.baseUrl=e||t.api.url}async request(t){const{endpoint:s,method:a="GET",data:r,headers:n={},timeout:o=this.defaultTimeout,useOfflineStorage:c=!0,retryOnFailure:u=!0}=t,l=`${this.baseUrl}${s}`,d=`req_${Date.now()}_${Math.random().toString(36).substr(2,9)}`;try{if("GET"===a&&c){const t=await this.getFromOfflineStorage(s);if(t)return{success:!0,data:t,fromCache:!0,timestamp:(new Date).toISOString()}}const t=await i.execute(()=>this.executeRequest(l,a,r||{},n,o,d),u?()=>this.getFallbackData(s):void 0);return c&&t&&await this.storeInOfflineStorage(s,t),{success:!0,data:t,timestamp:(new Date).toISOString()}}catch(h){if(e(h,{service:"api",operation:`${a.toLowerCase()}-${s}`},"medium"),c)try{const t=await this.getFromOfflineStorage(s);if(t)return{success:!0,data:t,fromCache:!0,timestamp:(new Date).toISOString()}}catch(m){}if("GET"!==a&&c&&r)try{await this.queueForSync(a,s,r)}catch(g){}let t="Request failed";return h instanceof Error&&(t=h.message.includes("Failed to fetch")||h.message.includes("NetworkError")?"Network connection error. Please check your internet connection and try again.":h.message.includes("timeout")?"Request timed out. Please try again.":h.message),{success:!1,error:t,timestamp:(new Date).toISOString()}}}async executeRequest(t,e,s,a,r,n){const i=new AbortController,o=setTimeout(()=>i.abort(),r);try{const r=await fetch(t,{method:e,headers:{"Content-Type":"application/json","X-Request-ID":n,...a},body:s?JSON.stringify(s):void 0,signal:i.signal});if(clearTimeout(o),!r.ok)throw new Error(`HTTP ${r.status}: ${r.statusText}`);return await r.json()}catch(c){if(clearTimeout(o),c instanceof Error){if("AbortError"===c.name)throw new Error("Request timeout");throw c}throw new Error("Unknown error occurred")}}async getFallbackData(t){try{const e=await o.execute(async()=>{const e=await this.getFromOfflineStorage(t);if(e)return e;throw new Error("No fallback data available")});if(e.success&&e.result)return e.result;throw new Error(`No cached data available for ${t}. Please check your internet connection and try again.`)}catch(e){if(e instanceof Error&&e.message.includes("No fallback data available"))throw new Error(`No cached data available for ${t}. Please check your internet connection and try again.`);throw e}}async getFromOfflineStorage(t){try{const e=this.getDataTypeFromEndpoint(t),s=this.getStorageId(t);return await c.getData(e,s)}catch(e){return null}}async storeInOfflineStorage(t,e){try{const s=this.getDataTypeFromEndpoint(t),a=this.getStorageId(t);await c.storeData(s,a,e)}catch(s){}}async queueForSync(t,e,s){try{const a="DELETE"===t?"delete":"PUT"===t?"update":"create";await c.addToSyncQueue(a,e,s)}catch(a){}}getDataTypeFromEndpoint(t){return t.includes("/buses")?"bus":t.includes("/routes")?"route":t.includes("/locations")?"location":t.includes("/drivers")?"driver":t.includes("/users")?"user":"bus"}getStorageId(t){return t.split("?")[0].replace(/[^a-zA-Z0-9]/g,"_")}async get(t,e){return this.request({endpoint:t,method:"GET",...e})}async post(t,e,s){return this.request({endpoint:t,method:"POST",data:e,...s})}async put(t,e,s){return this.request({endpoint:t,method:"PUT",data:e,...s})}async delete(t,e){return this.request({endpoint:t,method:"DELETE",...e})}async healthCheck(){return this.get("/health",{timeout:5e3,retryOnFailure:!0,useOfflineStorage:!1})}async getOfflineStats(){return await c.getStats()}async clearOfflineStorage(){return await c.clearAll()}async syncPendingData(){return await c.syncPendingData()}};const u=new class{constructor(t){}getBaseUrl(){const t=window.location.hostname;if("localhost"!==t&&"127.0.0.1"!==t&&"0.0.0.0"!==t&&!t.includes("devtunnels.ms")){return`http://${t}:3000`}return"http://localhost:3000"}async backendRequest(t,s){const r=s?.method||"GET",n={"Content-Type":"application/json"};try{const t=a.getAccessToken();t&&(n.Authorization=`Bearer ${t}`)}catch(i){}s?.headers&&Object.assign(n,s.headers);try{{const e=this.getBaseUrl(),a=await fetch(`${e}${t}`,{method:r,headers:n,body:s?.body,signal:AbortSignal.timeout(15e3)});if(!a.ok)throw new Error(`HTTP ${a.status}: ${a.statusText}`);return await a.json()}}catch(i){throw e(i,{service:"api",operation:`${r.toLowerCase()}-${t}`},"medium"),i}}async getHealth(){try{const t=`${this.getBaseUrl()}/health`,e=await fetch(t,{method:"GET",headers:{"Content-Type":"application/json","Cache-Control":"no-cache",Pragma:"no-cache"},signal:AbortSignal.timeout(5e3)});if(!e.ok)throw new Error(`HTTP ${e.status}: ${e.statusText}`);return await e.json()}catch(t){return{status:"unhealthy",timestamp:(new Date).toISOString(),uptime:process.uptime(),environment:"development",services:{database:{status:"unhealthy",details:{status:"disconnected",details:{currentTime:(new Date).toISOString(),postgresVersion:"unknown",poolSize:0,idleCount:0,waitingCount:0}}},api:{status:"down",database:"down"}}}}}async getAllBuses(){try{const t=await this.backendRequest("/buses");return t.success&&t.data?{success:!0,data:t.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(t){return{success:!1,data:[],timestamp:(new Date).toISOString()}}}async getBusInfo(t){try{const e=await this.backendRequest(`/buses/${t}`);return e.success&&e.data?{success:!0,data:e.data,timestamp:(new Date).toISOString()}:{success:!1,data:null,timestamp:(new Date).toISOString()}}catch(e){return{success:!1,data:null,timestamp:(new Date).toISOString()}}}async getRoutes(){try{const t=await this.backendRequest("/routes");return t.success&&t.data?{success:!0,data:t.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(t){return{success:!1,data:[],timestamp:(new Date).toISOString()}}}async getRouteInfo(t){try{const e=await this.backendRequest(`/routes/${t}`);return e.success&&e.data?{success:!0,data:e.data,timestamp:(new Date).toISOString()}:{success:!1,data:null,timestamp:(new Date).toISOString()}}catch(e){return{success:!1,data:null,timestamp:(new Date).toISOString()}}}async getAllDrivers(){try{const t=await this.backendRequest("/admin/drivers");return t.success&&t.data?{success:!0,data:t.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(t){return{success:!1,data:[],timestamp:(new Date).toISOString()}}}async getDriverInfo(t){try{const e=await this.backendRequest(`/admin/drivers/${t}`);return e.success&&e.data?{success:!0,data:e.data,timestamp:(new Date).toISOString()}:{success:!1,data:null,timestamp:(new Date).toISOString()}}catch(e){return{success:!1,data:null,timestamp:(new Date).toISOString()}}}async getLiveLocations(){try{const t=await this.backendRequest("/locations/current");return t.success&&t.data?{success:!0,data:t.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(t){return t&&"object"==typeof t&&null!==t&&"message"in t&&"string"==typeof t.message&&t.message.includes("401")?{success:!0,data:[],timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}}async updateLiveLocation(t,e,s){try{const a=await this.backendRequest("/locations/update",{method:"POST",body:JSON.stringify({busId:t,driverId:e,latitude:s.latitude,longitude:s.longitude,speed:s.speed,heading:s.heading,timestamp:(new Date).toISOString()})});return a.success&&a.data?{success:!0,data:a.data,timestamp:(new Date).toISOString()}:{success:!1,data:null,timestamp:(new Date).toISOString()}}catch(a){return{success:!1,data:null,timestamp:(new Date).toISOString()}}}async getRoutesInViewport(t){try{const[e,s]=t[0],[a,r]=t[1],n=await fetch(`${this.getBaseUrl()}/routes/viewport?minLng=${e}&minLat=${s}&maxLng=${a}&maxLat=${r}`,{method:"GET",headers:{"Content-Type":"application/json"},signal:AbortSignal.timeout(1e4)});if(!n.ok)throw new Error(`HTTP ${n.status}: ${n.statusText}`);const i=await n.json();return i.success&&i.data?{success:!0,data:i.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(e){return{success:!1,data:[],timestamp:(new Date).toISOString()}}}async getBusesInViewport(t){try{const[e,s]=t[0],[a,r]=t[1],n=await fetch(`${this.getBaseUrl()}/buses/viewport?minLng=${e}&minLat=${s}&maxLng=${a}&maxLat=${r}`,{method:"GET",headers:{"Content-Type":"application/json"},signal:AbortSignal.timeout(1e4)});if(!n.ok)throw new Error(`HTTP ${n.status}: ${n.statusText}`);const i=await n.json();return i.success&&i.data?{success:!0,data:i.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(e){return{success:!1,data:[],timestamp:(new Date).toISOString()}}}async getLiveLocationsInViewport(t){try{const[e,s]=t[0],[a,r]=t[1],n=await fetch(`${this.getBaseUrl()}/locations/viewport?minLng=${e}&minLat=${s}&maxLng=${a}&maxLat=${r}`,{method:"GET",headers:{"Content-Type":"application/json"},signal:AbortSignal.timeout(1e4)});if(!n.ok)throw new Error(`HTTP ${n.status}: ${n.statusText}`);const i=await n.json();return i.success&&i.data?{success:!0,data:i.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(e){return{success:!1,data:[],timestamp:(new Date).toISOString()}}}async getBusClusters(t,e){try{const[s,a]=t[0],[r,n]=t[1],i=await fetch(`${this.getBaseUrl()}/buses/clusters?minLng=${s}&minLat=${a}&maxLng=${r}&maxLat=${n}&zoom=${e}`,{method:"GET",headers:{"Content-Type":"application/json"},signal:AbortSignal.timeout(1e4)});if(!i.ok)throw new Error(`HTTP ${i.status}: ${i.statusText}`);const o=await i.json();return o.success&&o.data?{success:!0,data:o.data,timestamp:(new Date).toISOString()}:{success:!1,data:[],timestamp:(new Date).toISOString()}}catch(s){return{success:!1,data:[],timestamp:(new Date).toISOString()}}}};class l{static instance;locationCache=new Map;lastKnownLocations=new Map;routeEstimates=new Map;defaultLocations=new Map;CACHE_TTL=3e5;LAST_KNOWN_TTL=18e5;ROUTE_ESTIMATE_TTL=6e5;DEFAULT_LOCATIONS={ahmedabad:{latitude:23.0225,longitude:72.5714},vadodara:{latitude:22.3072,longitude:73.1812},surat:{latitude:21.1702,longitude:72.8311},rajkot:{latitude:22.3039,longitude:70.8022},gandhinagar:{latitude:23.2156,longitude:72.6369}};static getInstance(){return l.instance||(l.instance=new l),l.instance}getFallbackLocation(t,e){try{const e=this.getCachedLocation(t);if(e)return e;const s=this.getLastKnownLocation(t);if(s)return s;const a=this.getRouteEstimate(t);if(a)return a;const r=this.getDefaultLocation(t);return r||null}catch(a){const t=a instanceof Error?a.message:"Unknown fallback error";return s.logError(new Error(`Fallback data service error: ${t}`),{service:"map",operation:"fallback_data_retrieval"},"medium"),null}}cacheLocation(t){try{const e={busId:t.busId,driverId:t.driverId,latitude:t.latitude,longitude:t.longitude,timestamp:t.timestamp,speed:t.speed,heading:t.heading,source:"cache",confidence:1},s={data:e,timestamp:Date.now(),ttl:this.CACHE_TTL};this.locationCache.set(t.busId,s),this.lastKnownLocations.set(t.busId,{...e,source:"last_known",confidence:.9})}catch(e){e instanceof Error&&e.message}}getCachedLocation(t){const e=this.locationCache.get(t);if(!e)return null;return Date.now()-e.timestamp>e.ttl?(this.locationCache.delete(t),null):e.data}getLastKnownLocation(t){const e=this.lastKnownLocations.get(t);if(!e)return null;const s=Date.now()-new Date(e.timestamp).getTime();if(s>this.LAST_KNOWN_TTL)return this.lastKnownLocations.delete(t),null;const a=Math.max(0,1-s/this.LAST_KNOWN_TTL);return{...e,confidence:e.confidence*a}}getRouteEstimate(t){const e=this.routeEstimates.get(t);if(!e)return null;const s=Date.now()-new Date(e.timestamp).getTime();if(s>this.ROUTE_ESTIMATE_TTL)return this.routeEstimates.delete(t),null;const a=Math.max(0,1-s/this.ROUTE_ESTIMATE_TTL);return{...e,confidence:e.confidence*a}}getDefaultLocation(t){const e=this.defaultLocations.get(t);if(e)return e;const s=Object.keys(this.DEFAULT_LOCATIONS),a=s[this.hashString(t)%s.length],r=this.DEFAULT_LOCATIONS[a],n={busId:t,driverId:"unknown",latitude:r.latitude,longitude:r.longitude,timestamp:(new Date).toISOString(),source:"default",confidence:.1};return this.defaultLocations.set(t,n),n}setRouteEstimate(t,e){try{const s={busId:t,driverId:e.driverId||"unknown",latitude:e.latitude||0,longitude:e.longitude||0,timestamp:e.timestamp||(new Date).toISOString(),speed:e.speed,heading:e.heading,source:"route_estimate",confidence:.7};this.routeEstimates.set(t,s)}catch(s){s instanceof Error&&s.message}}clearBusData(t){this.locationCache.delete(t),this.lastKnownLocations.delete(t),this.routeEstimates.delete(t),this.defaultLocations.delete(t)}cleanupExpiredData(){const t=Date.now();for(const[e,s]of this.locationCache.entries())t-s.timestamp>s.ttl&&this.locationCache.delete(e);for(const[e,s]of this.lastKnownLocations.entries()){t-new Date(s.timestamp).getTime()>this.LAST_KNOWN_TTL&&this.lastKnownLocations.delete(e)}for(const[e,s]of this.routeEstimates.entries()){t-new Date(s.timestamp).getTime()>this.ROUTE_ESTIMATE_TTL&&this.routeEstimates.delete(e)}}getStats(){return{cacheSize:this.locationCache.size,lastKnownSize:this.lastKnownLocations.size,routeEstimatesSize:this.routeEstimates.size,defaultLocationsSize:this.defaultLocations.size}}hashString(t){let e=0;for(let s=0;s<t.length;s++){e=(e<<5)-e+t.charCodeAt(s),e&=e}return Math.abs(e)}toBusLocation(t){return{busId:t.busId,driverId:t.driverId,latitude:t.latitude,longitude:t.longitude,timestamp:t.timestamp,speed:t.speed,heading:t.heading,eta:void 0}}}const d=l.getInstance();setInterval(()=>{d.cleanupExpiredData()},3e5);const h=new class{buses={};previousLocations={};calculateSpeed(t,e,s,a,r){const n=this.toRadians(s-t),i=this.toRadians(a-e),o=Math.sin(n/2)*Math.sin(n/2)+Math.cos(this.toRadians(t))*Math.cos(this.toRadians(s))*Math.sin(i/2)*Math.sin(i/2),c=6371*(2*Math.atan2(Math.sqrt(o),Math.sqrt(1-o)))/(r/36e5);return Math.round(10*c)/10}toRadians(t){return t*(Math.PI/180)}updateBusLocation(t){const{busId:e,latitude:s,longitude:a,timestamp:r}=t,n=this.previousLocations[e];let i;if(n){const t=new Date(r).getTime()-new Date(n.timestamp).getTime();t>0&&(i=this.calculateSpeed(n.latitude,n.longitude,s,a,t))}this.buses[e]?(this.buses[e].currentLocation={...t,speed:i||t.speed},this.buses[e].eta=t.eta?.estimated_arrival_minutes):(this.buses[e]={busId:e,busNumber:`Bus ${e}`,routeName:"Route TBD",driverName:"Driver TBD",currentLocation:{...t,speed:i||t.speed},eta:t.eta?.estimated_arrival_minutes},this.syncBusFromAPI(e).catch(t=>{})),this.previousLocations[e]={latitude:s,longitude:a,timestamp:r}}getBus(t){return this.buses[t]||null}getAllBuses(){return Object.values(this.buses)}getBusesByRoute(t){return Object.values(this.buses).filter(e=>e.routeName===t)}async syncBusFromAPI(t,e){try{if(!e){const s=await u.getBusInfo(t);if(!s.success||!s.data)return;e=s.data}this.buses[t]?this.buses[t]={...this.buses[t],busNumber:e.number_plate||e.code||`Bus ${t}`,routeName:e.route_name||"Route TBD",driverName:e.driver_full_name||"Driver TBD"}:this.buses[t]={busId:t,busNumber:e.number_plate||e.code||`Bus ${t}`,routeName:e.route_name||"Route TBD",driverName:e.driver_full_name||"Driver TBD",currentLocation:{busId:t,driverId:e.assigned_driver_id||"",latitude:0,longitude:0,timestamp:(new Date).toISOString()}}}catch(s){}}async syncAllBusesFromAPI(){try{const t=await u.getAllBuses();t.success&&t.data&&t.data.forEach(t=>{this.syncBusFromAPI(t.id,t)})}catch(t){}}clearBuses(){this.buses={},this.previousLocations={}}getBusStats(){const t=Object.values(this.buses),e={};return t.forEach(t=>{const s=t.routeName;e[s]=(e[s]||0)+1}),{totalBuses:t.length,activeBuses:t.filter(t=>t.currentLocation).length,busesByRoute:e}}getActiveBuses(){const t=new Date(Date.now()-3e5);return Object.values(this.buses).filter(e=>new Date(e.currentLocation.timestamp)>t)}getBusLocationHistory(t){const e=this.buses[t];return e?[e.currentLocation]:[]}updateBusETA(t,e){this.buses[t]&&(this.buses[t].eta=e)}getBusesNearLocation(t,e,s=5){return Object.values(this.buses).filter(a=>{const r=a.currentLocation.latitude,n=a.currentLocation.longitude,i=this.toRadians(r-t),o=this.toRadians(n-e),c=Math.sin(i/2)*Math.sin(i/2)+Math.cos(this.toRadians(t))*Math.cos(this.toRadians(r))*Math.sin(o/2)*Math.sin(o/2);return 6371*(2*Math.atan2(Math.sqrt(c),Math.sqrt(1-c)))<=s})}},m=t.api.url;const g=new class{async makeRequest(e,s={}){let r;try{const n=a.getAccessToken();if(!n)throw new Error("No access token available");const i=new AbortController;r=setTimeout(()=>i.abort(),15e3);const o=m||t.api.url,c=await fetch(`${o}/admin${e}`,{...s,signal:i.signal,headers:{"Content-Type":"application/json",Authorization:`Bearer ${n}`,...s.headers}}),u=await c.json();if(r&&clearTimeout(r),!c.ok)throw 429===c.status?new Error("Rate limit exceeded. Please wait a moment and try again."):401===c.status?new Error("Authentication required. Please log in again."):403===c.status?new Error("Access denied. You do not have permission for this action."):404===c.status?new Error("Resource not found."):409===c.status?new Error(u.message||"Resource already exists"):c.status>=500?new Error("Server error. Please try again later."):new Error(u.message||u.error||"Request failed");return u}catch(n){return r&&clearTimeout(r),{success:!1,error:n instanceof Error?n.message:"Request failed"}}}async getAnalytics(){return this.makeRequest("/analytics")}async getSystemHealth(){return this.makeRequest("/health")}async getAllBuses(){return await this.makeRequest("/buses")}async getBusById(t){return this.makeRequest(`/buses/${t}`)}async createBus(t){return this.makeRequest("/buses",{method:"POST",body:JSON.stringify(t)})}async updateBus(t,e){return this.makeRequest(`/buses/${t}`,{method:"PUT",body:JSON.stringify(e)})}async deleteBus(t){return this.makeRequest(`/buses/${t}`,{method:"DELETE"})}async getAllDrivers(){return await this.makeRequest("/drivers")}async getAssignedDrivers(){return await this.makeRequest("/assigned-drivers")}async getDriverById(t){return this.makeRequest(`/drivers/${t}`)}async assignDriverToBus(t,e){return this.makeRequest(`/drivers/${t}/assign-bus`,{method:"POST",body:JSON.stringify({busId:e})})}async unassignDriverFromBus(t){return this.makeRequest(`/drivers/${t}/unassign-bus`,{method:"POST"})}async createDriver(t){return this.makeRequest("/drivers",{method:"POST",body:JSON.stringify(t)})}async updateDriver(t,e){return this.makeRequest(`/drivers/${t}`,{method:"PUT",body:JSON.stringify(e)})}async deleteDriver(t){return this.makeRequest(`/drivers/${t}`,{method:"DELETE"})}async getAllRoutes(){return await this.makeRequest("/routes")}async getRouteById(t){return this.makeRequest(`/routes/${t}`)}async createRoute(t){return this.makeRequest("/routes",{method:"POST",body:JSON.stringify(t)})}async updateRoute(t,e){return this.makeRequest(`/routes/${t}`,{method:"PUT",body:JSON.stringify(e)})}async deleteRoute(t){return this.makeRequest(`/routes/${t}`,{method:"DELETE"})}},p=t.api.url;class w{static async makeRequest(e,s={}){let r=a.getAccessToken();if(!r&&a.isAuthenticated()){if(!(await a.refreshSession()).success)throw new Error("Authentication required");r=a.getAccessToken()}const n={"Content-Type":"application/json",...r&&{Authorization:`Bearer ${r}`}},i=p||t.api.url;return fetch(`${i}/storage${e}`,{...s,headers:{...n,...s.headers}})}static async uploadBusImage(e,s){try{const r=a.getAccessToken();if(!r)return{success:!1,error:"Authentication required"};const n=new FormData;n.append("image",s),n.append("busId",e);const i=p||t.api.url,o=await fetch(`${i}/storage/upload/bus-image`,{method:"POST",headers:{Authorization:`Bearer ${r}`},body:n});if(!o.ok){return{success:!1,error:(await o.json()).error||"Upload failed"}}const c=await o.json();return{success:!0,url:c.url,fileName:c.fileName}}catch(r){return{success:!1,error:"Network error during upload"}}}static async uploadDriverPhoto(e,s){try{const r=a.getAccessToken();if(!r)return{success:!1,error:"Authentication required"};const n=new FormData;n.append("photo",s),n.append("driverId",e);const i=p||t.api.url,o=await fetch(`${i}/storage/upload/driver-photo`,{method:"POST",headers:{Authorization:`Bearer ${r}`},body:n});if(!o.ok){return{success:!1,error:(await o.json()).error||"Upload failed"}}const c=await o.json();return{success:!0,url:c.url,fileName:c.fileName}}catch(r){return{success:!1,error:"Network error during upload"}}}static async uploadRouteMap(e,s){try{const r=a.getAccessToken();if(!r)return{success:!1,error:"Authentication required"};const n=new FormData;n.append("map",s),n.append("routeId",e);const i=p||t.api.url,o=await fetch(`${i}/storage/upload/route-map`,{method:"POST",headers:{Authorization:`Bearer ${r}`},body:n});if(!o.ok){return{success:!1,error:(await o.json()).error||"Upload failed"}}const c=await o.json();return{success:!0,url:c.url,fileName:c.fileName}}catch(r){return{success:!1,error:"Network error during upload"}}}static async getSignedUrl(t,e){try{const s=await this.makeRequest(`/signed-url/${t}/${e}`);if(!s.ok){return{success:!1,error:(await s.json()).error||"Failed to get signed URL"}}const a=await s.json();return{success:!0,signedUrl:a.signedUrl,expiresIn:a.expiresIn}}catch(s){return{success:!1,error:"Network error"}}}static async deleteFile(t,e,s){try{const a=await this.makeRequest(`/delete/${t}/${e}`,{method:"DELETE",body:JSON.stringify({fileUrl:s})});if(!a.ok){return{success:!1,error:(await a.json()).error||"Delete failed"}}return{success:!0}}catch(a){return{success:!1,error:"Network error during deletion"}}}static async getFileInfo(t,e){try{const s=await this.makeRequest(`/info/${t}/${e}`);if(!s.ok){return{success:!1,hasFile:!1,error:(await s.json()).error||"Failed to get file info"}}const a=await s.json();return{success:!0,hasFile:a.hasFile,url:a.url,info:a.info}}catch(s){return{success:!1,hasFile:!1,error:"Network error"}}}static async listFiles(t){try{const e=await this.makeRequest(`/list/${t}`);if(!e.ok){return{success:!1,error:(await e.json()).error||"Failed to list files"}}return{success:!0,files:(await e.json()).files}}catch(e){return{success:!1,error:"Network error"}}}static validateFile(t,e,s){return t?e.includes(t.type)?t.size>s?{isValid:!1,error:`File too large. Maximum size: ${s/1048576}MB`}:{isValid:!0}:{isValid:!1,error:`Invalid file type. Allowed types: ${e.join(", ")}`}:{isValid:!1,error:"No file selected"}}static validateImage(t){return this.validateFile(t,["image/jpeg","image/jpg","image/png","image/webp"],5242880)}static validateDocument(t){return this.validateFile(t,["application/pdf","image/jpeg","image/jpg","image/png"],10485760)}}export{w as S,g as a,u as b,h as c,d as f};
